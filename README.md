# Фінальний проєкт курсу "Basic Algorithms and Data Structures"

## Завдання 1. Однозв’язний список

У цьому завданні реалізовано базову структуру даних - однозв’язний список, а також три алгоритмічні операції:

**I. Реверсування списку**

Змінює напрямок посилань next так, що:
```
3 → 2 → 1 → None 
⟶  
1 → 2 → 3 → None   
```

**II. Сортування однозв’язного списку (Merge Sort)**

#### Використано сортування злиттям, оскільки:

- воно добре працює з ланцюговими структурами без довільного доступу (O(n log n)),
- не вимагає додаткових масивів,
- легко реалізується рекурсивно.

#### Реалізовано функції:
- merge_sort(head) - рекурсивне сортування
- get_middle(head) - пошук середини (slow/fast pointers)
- sorted_merge(a, b) - злиття двох сортованих списків

**III. Злиття двох відсортованих списків**

Алгоритм об’єднує два sorted-списки в один sorted:
```
1 → 3 → 7  
та  
5 → 10 → 15 → 20 → 25  

⟶  
1 → 3 → 5 → 7 → 10 → 15 → 20 → 25
```

## Завдання 2. Рекурсія - фрактал “Дерево Піфагора”

У цьому завданні реалізовано побудову рекурсивного фракталу “дерево Піфагора” на основі гілок, що розгалужуються під кутами ±45°.

Це класичний приклад рекурсії, де кожна гілка повторює структуру всього дерева.

### Мета завдання
- продемонструвати використання рекурсії для побудови фракталів;
- надати користувачу можливість керувати глибиною рекурсії (depth);
- створити візуальну графіку за допомогою matplotlib.

### Принцип побудови фрактала
1. Малюємо основну вертикальну гілку.
2. Від її вершини малюємо 2 нові:
	  - одна під кутом +45°,
	  - друга під -45°.
3. Довжина кожної нової гілки зменшується, наприклад ×0.7.
4. Для кожної нової гілки рекурсивно викликається той самий алгоритм.
5. Коли depth == 0 - малювання завершується.

Це демонструє самоподібність - ключову властивість фракталів.

## Завдання 3. Алгоритм Дейкстри з використанням бінарної купи

У цьому завданні реалізовано алгоритм Дейкстри для знаходження найкоротших шляхів у зваженому графі.
Для оптимізації вибору вершини з найменшою відстанню застосовано бінарну купу (heapq), що зменшує складність алгоритму.

### Мета завдання
- побудувати структуру графа у вигляді списків суміжності;
- реалізувати алгоритм Дейкстри для обчислення мінімальних відстаней;
- використовувати бінарну піраміду для ефективного вибору наступної вершини;
- відновити найкоротший шлях до будь-якої вершини.

### Як працює алгоритм Дейкстри

Алгоритм застосовується до орієнтованих або неорієнтованих зважених графів без від’ємних ваг.

1. Початкова вершина має відстань 0.
2. Усі інші вершини отримують +∞ (невідомий шлях).
3. За допомогою бінарної купи вибирається вершина з мінімальною поточною відстанню.
4. Відстані до сусідів оновлюються, якщо знайдено коротший шлях.
5. Процес повторюється, доки не буде оброблено всі вершини.

### Візуалізація графа та найкоротшого шляху

Для зручності аналізу реалізовано графічну візуалізацію графа:

- Вершини зображені у вигляді кругів.
- На ребрах вказані ваги.
- Найкоротший шлях, знайдений алгоритмом Дейкстри, автоматично підсвічується червоним кольором.

### Висновки
- Реалізовано класичний алгоритм Дейкстри на зваженому графі.
- Використання бінарної купи значно підвищує продуктивність на великих графах.
- З’явилась можливість не тільки знаходити відстані, але й відновлювати сам маршрут.
- Структура коду дозволяє легко додавати нові вершини та ребра.
  - Візуалізація дозволила переконатися, що алгоритм коректно обирає ребра з мінімальною вагою та формує оптимальні маршрути навіть у складних графах.
  - Порівняння текстового та графічного результатів підтверджує правильність реалізації.

## Завдання 4. Візуалізація бінарної купи

У цьому завданні потрібно було використати готовий код для побудови бінарного дерева й адаптувати його так, щоб він міг візуалізувати бінарну купу (heap).
Бінарна купа зберігається у вигляді масиву, але логічно являє собою повне бінарне дерево - тому завдання полягало у відтворенні цієї структури графічно.

### Мета завдання
- проаналізувати код побудови та візуалізації бінарного дерева;
- зрозуміти, як розміщуються елементи дерева в просторі;
- навчитися будувати дерево зі спискової структури купи;
- реалізувати функцію, що автоматично переводить список у дерево Node;
- вивести купу на екран у вигляді реального бінарного дерева.

### Як влаштована бінарна купа

Хоча купа зберігається у списку, вона логічно відповідає повному бінарному дереву.

Для елемента з індексом **i**:

	- лівий нащадок → 2 * i + 1
	- правий нащадок → 2 * i + 2

Це означає, що за індексами можна легко побудувати дерево без додаткових структур.

### Основна ідея розв’язання

1. Взяти список, який представляє купу.
2. Створити список об’єктів Node:
    ```
    nodes = [Node(key) for key in heap_list]
    ```
3. Для кожного вузла обчислити індекси дітей і встановити:
    ```
    nodes[i].left = nodes[left_index]
    nodes[i].right = nodes[right_index]
    ```
4. Коренем дерева є елемент з індексом 0.
5. Передати корінь у функцію draw_tree() - яка вже вміє малювати бінарні дерева.

### Приклад результату

В результаті виклика draw_heap(data) користувач отримує повноцінне дерево, яке представляє структуру бінарної купи. Вивід графічний, добре відформатований і пропорційний.

## Завдання 5. Візуалізація обходу бінарного дерева (DFS та BFS)

У цьому завданні реалізовано програму на Python, яка візуалізує обхід бінарного дерева двома способами:

  - обхід у глибину (DFS) -із використанням стеку
  - обхід у ширину (BFS) - із використанням черги

Для кожного порядку обходу кожний вузол отримує унікальний колір, що плавно змінюється від темного до світлого. Це дозволяє наочно побачити послідовність відвідування вершини у дереві.

### Мета завдання
- зібрати бінарне дерево у вигляді об’єктів класу Node;
- реалізувати обходи дерева без рекурсії;
- згенерувати послідовність кольорів (градієнт від темного до світлого);
- присвоїти вузлам кольори у тому порядку, в якому вони були відвідані;
- візуалізувати дерево за допомогою NetworkX + Matplotlib;
- забезпечити можливість візуального порівняння DFS та BFS.

### Висновки
- Побудовано повну систему для візуалізації обходів бінарного дерева.
- Алгоритми DFS і BFS реалізовано ітеративно, без рекурсії.
- Застосовано механізм кольорового градієнта, що чудово демонструє порядок відвідування вузлів.
- Використання бібліотек NetworkX та Matplotlib дозволило створити чисту, інформативну графічну модель.
- Код легко розширювати: можна додати анімацію, підсвічування або інші стилі обходів.

## Завдання 6. Жадібні алгоритми та динамічне програмування

“Вибір страв з максимальною калорійністю при обмеженому бюджеті”

У цьому завданні реалізовано два різні підходи до розв’язання задачі максимізації калорійності при заданому бюджеті:

- Жадібний алгоритм, що робить локально найвигідний вибір;
- Алгоритм динамічного програмування, який знаходить глобально оптимальне розв’язання.

Дані подані у вигляді словника, де кожна страва має свою вартість та калорійність.

### Вхідні дані
```
items = {
  "pizza": {"cost": 50, "calories": 300},
  "hamburger": {"cost": 40, "calories": 250},
  "hot-dog": {"cost": 30, "calories": 200},
  "pepsi": {"cost": 10, "calories": 100},
  "cola": {"cost": 15, "calories": 220},
  "potato": {"cost": 25, "calories": 350}
}
```

### Мета
Знайти такий набір страв, щоб:

- не перевищити бюджет,
- отримати якомога більше калорій,
- порівняти результат жадібного алгоритму з результатом динамічного програмування.

### Висновки
- Жадібний алгоритм працює швидко, але приймає локально оптимальні рішення, тому може пропустити кращу комбінацію.
- Алгоритм динамічного програмування системно перебирає всі варіанти та завжди знаходить глобально оптимальне рішення.
- У випадку з вибором страв DP демонструє значно кращий результат при тому ж бюджеті.
- Обидва підходи важливі:
    - жадібні корисні, коли потрібна швидкість;
    - DP - коли потрібен оптимальний результат.

## Завдання 7. Метод Монте-Карло для оцінки ймовірностей сум при киданні двох кубиків

У цьому завданні реалізовано симуляцію методу Монте-Карло для визначення ймовірностей випадання сум від 2 до 12 при киданні двох шестигранних кубиків.

### Метою було:

- змоделювати велику кількість кидків (виконали 100 000);
- обчислити частоти та ймовірності сум, що випали;
- порівняти результати Монте-Карло з аналітичними значеннями, які відомі з теорії;
- побудувати графік та таблицю ймовірностей у відсотках.

### Результати Монте-Карло 

```
Сума |   Монте-Карло, % |    Аналітична, %
----------------------------------------------
   2 |            2.81% |            2.78%
   3 |            5.58% |            5.56%
   4 |            8.32% |            8.33%
   5 |           11.01% |           11.11%
   6 |           13.76% |           13.89%
   7 |           16.69% |           16.67%
   8 |           14.01% |           13.89%
   9 |           11.17% |           11.11%
  10 |            8.37% |            8.33%
  11 |            5.50% |            5.56%
  12 |            2.77% |            2.78%
```

### Аналіз та висновки

Результати, отримані методом Монте-Карло, дуже близькі до аналітичних, а всі відхилення знаходяться в межах статистичної похибки, що є нормальним для стохастичних симуляцій.

### Основні висновки:
  
1. Тренд аналітичних ймовірностей повністю відтворюється:
   - найчастіша сума - 7, що збігається з теорією;
   - найрідкісніші - 2 та 12.
2. Відхилення між Монте-Карло та аналітичними значеннями не перевищують ~0.2%, 
   що відповідає очікуваній дисперсії при 100 000 експериментах.
3. Зі збільшенням кількості симуляцій точність Монте-Карло буде ще ближчою до теоретичної.
4. Метод Монте-Карло чудово демонструє закон великих чисел: емпіричні ймовірності 
   наближаються до справжніх при збільшенні кількості спроб.
  
### Підсумок

Метод Монте-Карло підтвердив аналітичний розподіл сум при киданні двох кубиків.
Симуляція показала, що навіть за 100 000 експериментів різниця між теорією та практикою є мінімальною, а розподіл повністю збігається з математично очікуваним.

